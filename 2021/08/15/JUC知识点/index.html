<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JUC知识点 | 叮当园</title><meta name="keywords" content="多线程"><meta name="author" content="dingdang"><meta name="copyright" content="dingdang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="多线程基础进程与线程的区别： 进程：有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。 线程：堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。  死锁 多线程死锁：同步中嵌套同步,导致锁无法释放。 死锁解决办法：不要在同步中嵌套同步  123456789101112131415161718192021222324252627282930313233343">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC知识点">
<meta property="og:url" content="https://dingdang0.github.io/2021/08/15/JUC%E7%9F%A5%E8%AF%86%E7%82%B9/index.html">
<meta property="og:site_name" content="叮当园">
<meta property="og:description" content="多线程基础进程与线程的区别： 进程：有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。 线程：堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。  死锁 多线程死锁：同步中嵌套同步,导致锁无法释放。 死锁解决办法：不要在同步中嵌套同步  123456789101112131415161718192021222324252627282930313233343">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://api.mz-moe.cn/img.php">
<meta property="article:published_time" content="2021-08-15T10:35:08.949Z">
<meta property="article:modified_time" content="2021-08-15T10:38:00.011Z">
<meta property="article:author" content="dingdang">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://api.mz-moe.cn/img.php"><link rel="shortcut icon" href="https://portrait.gitee.com/uploads/avatars/user/2475/7426089_dingdang0_1593615956.png!avatar60"><link rel="canonical" href="https://dingdang0.github.io/2021/08/15/JUC%E7%9F%A5%E8%AF%86%E7%82%B9/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JUC知识点',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-08-15 18:38:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="叮当园" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://portrait.gitee.com/uploads/avatars/user/2475/7426089_dingdang0_1593615956.png!avatar60" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://api.mz-moe.cn/img.php')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">叮当园</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JUC知识点</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-15T10:35:08.949Z" title="发表于 2021-08-15 18:35:08">2021-08-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-15T10:38:00.011Z" title="更新于 2021-08-15 18:38:00">2021-08-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">21.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>71分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JUC知识点"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h1><h2 id="进程与线程的区别："><a href="#进程与线程的区别：" class="headerlink" title="进程与线程的区别："></a>进程与线程的区别：</h2><blockquote>
<p>进程：有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。</p>
<p>线程：堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。</p>
</blockquote>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><blockquote>
<p>多线程死锁：同步中嵌套同步,导致锁无法释放。</p>
<p>死锁解决办法：不要在同步中嵌套同步</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6DeadLock</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程任务对象</span></span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="comment">//创建三个窗口对象</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(ticket, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(ticket, <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(ticket, <span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">​</span><br><span class="line">        <span class="comment">//卖票</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">        Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;窗口1&quot;</span>.equals(name)) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                        sell(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sell(name);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ticket &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;卖票：&quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h2><ul>
<li><p>设置退出标志，使线程正常退出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo8Exit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> exit = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (exit) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程执行！&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">100l</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000l</span>);</span><br><span class="line">        exit = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;退出标识位设置成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>使用interrupt()方法中断线程。</p>
<blockquote>
<p><strong>1)线程处于阻塞状态</strong></p>
<p>如使用了sleep,同步锁的wait,socket中的receiver,accept等方法时，会使线程处于阻塞状态。当调用线程的interrupt()方法时，会抛出InterruptException异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后break跳出循环状态，从而让我们有机会结束这个线程的执行。</p>
<p><strong>2)线程未处于阻塞状态</strong></p>
<p>使用isInterrupted()判断线程的中断标志来退出循环。当使用interrupt()方法时，中断标志就会置true，和使用自定义的标志来控制循环是一样的道理。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo9Interrupt</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> exit = <span class="keyword">true</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (exit) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程执行！&quot;</span>);</span><br><span class="line">​</span><br><span class="line">                        <span class="comment">//判断线程的中断标志来退出循环</span></span><br><span class="line">                        <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">​</span><br><span class="line">                        Thread.sleep(<span class="number">100l</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        <span class="comment">//线程处于阻塞状态,当调用线程的interrupt()方法时，</span></span><br><span class="line">                        <span class="comment">//会抛出InterruptException异常,跳出循环</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">​</span><br><span class="line">        Thread.sleep(<span class="number">1000l</span>);</span><br><span class="line">        <span class="comment">//中断线程</span></span><br><span class="line">        t.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程中断了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用stop方法强行终止线程（不推荐使用Thread.stop, 这种终止线程运行的方法已经被废弃，使用它们是极端不安全的！）</p>
</li>
</ul>
<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><ul>
<li><p>优先级priority</p>
<blockquote>
<p>在JAVA线程中，通过一个int priority来控制优先级，范围为1-10，其中10最高，默认值为5。子线程继承父线程优先级，方法：Thread.setPriority(1);</p>
</blockquote>
</li>
<li><p>join()方法</p>
<blockquote>
<p>join作用是让其他线程变为等待。thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。</p>
</blockquote>
</li>
<li><p>yield方法</p>
</li>
</ul>
<h1 id="多线程进阶"><a href="#多线程进阶" class="headerlink" title="多线程进阶"></a>多线程进阶</h1><blockquote>
<p>三特性：原子性，可见性，有序性</p>
</blockquote>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="1-JVM内存结构"><a href="#1-JVM内存结构" class="headerlink" title="1. JVM内存结构"></a>1. JVM内存结构</h3><p><img src="https://gitee.com/dingdang0/images/raw/master/img/2021/spring/20210305090946.png" alt="内存结构"></p>
<h3 id="2-Java对象模型"><a href="#2-Java对象模型" class="headerlink" title="2. Java对象模型"></a>2. Java对象模型</h3><blockquote>
<p>Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。</p>
<p>HotSpot虚拟机中（Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机），设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。</p>
<p>每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个<code>instanceKlass</code>对象，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个<code>instanceOopDesc</code>对象，这个对象中包含了对象头以及实例数据。</p>
</blockquote>
<p><img src="https://gitee.com/dingdang0/images/raw/master/img/2021/spring/20210305091010.jpeg" alt="对象模型"></p>
<h3 id="3-java内存模型-JMM"><a href="#3-java内存模型-JMM" class="headerlink" title="3. java内存模型(JMM)"></a>3. java内存模型(JMM)</h3><blockquote>
<p>一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。</p>
</blockquote>
<p><img src="https://gitee.com/dingdang0/images/raw/master/img/2021/spring/20210305091049.png" alt="内存模型"></p>
<blockquote>
<p>JMM线程操作内存的基本的规则：</p>
<p>第一条关于线程与主内存：线程对共享变量的所有操作都必须在自己的工作内存（本地内存）中进行，不能直接从主内存中读写</p>
<p>第二条关于线程间本地内存：不同线程之间无法直接访问其他线程本地内存中的变量，线程间变量值的传递需要经过主内存来完成。</p>
<ul>
<li><p><strong>主内存</strong></p>
<p>主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。</p>
</li>
<li><p><strong>本地内存</strong></p>
<p>主要存储当前方法的所有本地变量信息(本地内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的本地内存，即<strong>线程中的本地变量对其它线程是不可见的</strong>，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。</p>
</li>
</ul>
</blockquote>
<h4 id="可见性问题例子"><a href="#可见性问题例子" class="headerlink" title="可见性问题例子"></a>可见性问题例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1Jmm</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">​</span><br><span class="line">        JmmDemo demo = <span class="keyword">new</span> JmmDemo();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(demo);</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        demo.flag = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;已经修改为false&quot;</span>);</span><br><span class="line">        System.out.println(demo.flag);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JmmDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程执行。。。&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程结束。。。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><blockquote>
<p>synchronized可以保证并发的原子性，可见性，有序性</p>
</blockquote>
<h3 id="1-synchronized解决可见性过程"><a href="#1-synchronized解决可见性过程" class="headerlink" title="1.synchronized解决可见性过程"></a>1.synchronized解决可见性过程</h3><blockquote>
<p>JMM关于synchronized的两条规定：</p>
<p>线程解锁前（退出同步代码块时）：必须把自己工作内存中共享变量的最新值刷新到主内存中</p>
<p>线程加锁时（进入同步代码块时）：将清空本地内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（加锁与解锁是同一把锁）</p>
</blockquote>
<h4 id="synchronized实现可见性的过程"><a href="#synchronized实现可见性的过程" class="headerlink" title="synchronized实现可见性的过程"></a><strong>synchronized实现可见性的过程</strong></h4><ol>
<li>获得互斥锁（同步获取锁）</li>
<li>清空本地内存</li>
<li>从主内存拷贝变量的最新副本到本地内存</li>
<li>执行代码</li>
<li>将更改后的共享变量的值刷新到主内存</li>
<li>释放互斥锁</li>
</ol>
<h3 id="2-synchronized实现同步原理"><a href="#2-synchronized实现同步原理" class="headerlink" title="2. synchronized实现同步原理"></a>2. synchronized实现同步原理</h3><p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p>
<ol>
<li>普通同步方法，锁是当前实例对象this</li>
<li>静态同步方法，锁是当前类的class对象</li>
<li>同步方法块，锁是括号里面的对象</li>
</ol>
<p>当一个线程访问同步代码块时，它首先是需要得到锁才能执行同步代码，当退出或者抛出异常时必须要释放锁。</p>
<p><strong>同步代码块是使用monitorenter和monitorexit这两个jvm指令实现的</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">synchronized_test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (synchronized_test.class)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>javap -c synchronized_test.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;synchronized_test.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cn</span>.<span class="title">qinggui</span>.<span class="title">thread1</span>.<span class="title">synchronized_test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> cn.qinggui.thread1.synchronized_test();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: ldc           #<span class="number">2</span>                  <span class="comment">// class cn/qinggui/thread1/synchronized_test</span></span><br><span class="line">       <span class="number">2</span>: dup</span><br><span class="line">       <span class="number">3</span>: astore_1</span><br><span class="line">       <span class="number">4</span>: monitorenter</span><br><span class="line">       <span class="number">5</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">8</span>: ldc           #<span class="number">4</span>                  <span class="comment">// String hello</span></span><br><span class="line">      <span class="number">10</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">13</span>: aload_1</span><br><span class="line">      <span class="number">14</span>: monitorexit</span><br><span class="line">      <span class="number">15</span>: goto          <span class="number">23</span></span><br><span class="line">      <span class="number">18</span>: astore_2</span><br><span class="line">      <span class="number">19</span>: aload_1</span><br><span class="line">      <span class="number">20</span>: monitorexit</span><br><span class="line">      <span class="number">21</span>: aload_2</span><br><span class="line">      <span class="number">22</span>: athrow</span><br><span class="line">      <span class="number">23</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">5</span>    <span class="number">15</span>    <span class="number">18</span>   any</span><br><span class="line">          <span class="number">18</span>    <span class="number">21</span>    <span class="number">18</span>   any</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>monitorenter和monitorexit这两个jvm指令实现锁的使用，主要是基于 Mark Word和、monitor。 </p>
<p><strong>Mark Word</strong></p>
<p>Hotspot虚拟机的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。其中Klass Point是是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word用于存储对象自身的运行时数据，它是synchronized实现轻量级锁和偏向锁的关键。</p>
<p>Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit），但是如果对象是数组类型，则需要三个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。下图是Java对象头的存储结构（32位虚拟机）：</p>
<p><img src="https://gitee.com/dingdang0/images/raw/master/img/2021/spring/20210305091050.png" alt="img"></p>
<p>对象头信息是与对象自身定义的数据无关的额外存储成本，但是考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己的存储空间，也就是说，Mark Word会随着程序的运行发生变化，变化状态如下（32位虚拟机）：</p>
<ul>
<li><p><strong>monitor</strong></p>
<p>什么是Monitor？我们可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象都带了一把看不见的锁，它叫做内部锁或者Monitor锁。</p>
<p>Monitor 是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。其结构如下：</p>
</li>
</ul>
<img src="https://gitee.com/dingdang0/images/raw/master/img/2021/spring/20210305091051.png" alt="img" style="zoom: 67%;" />

<ul>
<li><strong>Owner</strong>：初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；</li>
<li><strong>EntryQ</strong>:关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程。</li>
<li><strong>RcThis</strong>:表示blocked或waiting在该monitor record上的所有线程的个数。</li>
<li><strong>Nest</strong>:用来实现重入锁的计数。</li>
<li><strong>HashCode</strong>:保存从对象头拷贝过来的HashCode值（可能还包含GC age）。</li>
<li><strong>Candidate</strong>:用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。</li>
</ul>
<h3 id="相关锁概念"><a href="#相关锁概念" class="headerlink" title="相关锁概念"></a>相关锁概念</h3><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。</p>
<p>自旋等待不能替代阻塞，虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作</p>
<h4 id="适应自旋锁"><a href="#适应自旋锁" class="headerlink" title="适应自旋锁"></a>适应自旋锁</h4><p>所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</p>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除</p>
<blockquote>
<p>比如我们用到的StringBuffer和Vector自带有锁，但在单线程中会被消除</p>
</blockquote>
<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如上面实例：vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的。而偏向锁只需要检查是否为偏向锁、锁标识为以及ThreadID即可，可以减少不必要的CAS操作。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>引入轻量级锁的主要目的是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁。轻量级锁主要使用CAS进行原子操作。</p>
<p>但是对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢。</p>
<h4 id="重量锁"><a href="#重量锁" class="headerlink" title="重量锁"></a>重量锁</h4><p>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock（互斥锁）实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p>
<h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><blockquote>
<p>volatile保证内存可见性，有序性，但不能保证原子性</p>
</blockquote>
<h3 id="Volatile实现内存可见性的过程"><a href="#Volatile实现内存可见性的过程" class="headerlink" title="Volatile实现内存可见性的过程"></a><strong>Volatile实现内存可见性的过程</strong></h3><ul>
<li>线程写Volatile变量的过程：</li>
</ul>
<ol>
<li>改变线程本地内存中Volatile变量副本的值；</li>
<li>将改变后的副本的值从本地内存刷新到主内存</li>
</ol>
<ul>
<li>线程读Volatile变量的过程：</li>
</ul>
<ol>
<li>从主内存中读取Volatile变量的最新值到线程的本地内存中</li>
<li>从本地内存中读取Volatile变量的副本</li>
</ol>
<h3 id="Volatile实现内存可见性原理："><a href="#Volatile实现内存可见性原理：" class="headerlink" title="Volatile实现内存可见性原理："></a><strong>Volatile实现内存可见性原理：</strong></h3><p>写操作时，通过在写操作指令后加入一条store屏障指令，让本地内存中变量的值能够刷新到主内存中</p>
<p>读操作时，通过在读操作前加入一条load屏障指令，及时读取到变量在主内存的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS: 内存屏障（Memory Barrier）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序</span><br></pre></td></tr></table></figure>

<h3 id="代替volatile实现原子性方法"><a href="#代替volatile实现原子性方法" class="headerlink" title="代替volatile实现原子性方法"></a>代替volatile实现原子性方法</h3><ul>
<li>用synchronized代替</li>
<li>使用ReentrantLock可重入锁</li>
<li>使用Atomic原子操作</li>
</ul>
<h3 id="Volatile-适合使用场景"><a href="#Volatile-适合使用场景" class="headerlink" title="Volatile 适合使用场景"></a>Volatile 适合使用场景</h3><p>a）对变量的写入操作不依赖其当前值</p>
<p>不满足：number++、count=count*5等</p>
<p>满足：boolean变量、直接赋值的变量等</p>
<p>b）该变量没有包含在具有其他变量的不变式中</p>
<p>不满足：不变式 low&lt;up</p>
<p>总结：变量真正独立于其他变量和自己以前的值，在单独使用的时候，适合用volatile</p>
<h3 id="synchronized和volatile比较"><a href="#synchronized和volatile比较" class="headerlink" title="synchronized和volatile比较"></a>synchronized和volatile比较</h3><p>a）volatile不需要加锁，比synchronized更轻便，不会阻塞线程</p>
<p>b）synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性</p>
<p>与锁相比，Volatile 变量是一种非常简单但同时又非常脆弱的同步机制，它在某些情况下将提供优于锁的性能和伸缩性。如果严格遵循 volatile 的使用条件（<strong>变量真正独立于其他变量和自己以前的值</strong> ） 在某些情况下可以使用 volatile 代替 synchronized 来优化代码提升效率。</p>
<h2 id="JUC内容"><a href="#JUC内容" class="headerlink" title="JUC内容"></a>JUC内容</h2><h3 id="J-U-C-框架包含的内容"><a href="#J-U-C-框架包含的内容" class="headerlink" title="J.U.C 框架包含的内容"></a>J.U.C 框架包含的内容</h3><ul>
<li><p>AbstractQueuedSynchronizer（AQS框架），J.U.C 中实现锁和同步机制的基础；</p>
</li>
<li><p>Locks &amp; Condition（锁和条件变量），比 synchronized、wait、notify 更细粒度的锁机制；</p>
</li>
<li><p>Executor 框架（线程池、Callable、Future），任务的执行和调度框架；</p>
</li>
<li><p>Synchronizers（同步器），主要用于协助线程同步，有 CountDownLatch、CyclicBarrier、Semaphore、Exchanger；</p>
</li>
<li><p>Atomic Variables（原子变量），方便程序员在多线程环境下，无锁的进行原子操作，核心操作是 CAS 原子操作，所谓的 CAS 操作，即 compare and swap，指的是将预期值与当前变量的值比较(compare)，如果相等则使用新值替换(swap)当前变量，否则不作操作；</p>
</li>
<li><p>BlockingQueue（阻塞队列），阻塞队列提供了可阻塞的入队和出对操作，如果队列满了，入队操作将阻塞直到有空间可用，如果队列空了，出队操作将阻塞直到有元素可用；</p>
</li>
<li><p>Concurrent Collections（并发容器），说到并发容器，不得不提同步容器。在 JDK1.5 之前，为了线程安全，我们一般都是使用同步容器，同步容器主要的缺点是：对所有容器状态的访问都串行化，严重降低了并发性；某些复合操作，仍然需要加锁来保护；迭代期间，若其它线程并发修改该容器，会抛出 ConcurrentModificationException 异常，即快速失败机制；</p>
</li>
<li><p>Fork/Join 并行计算框架，这块内容是在 JDK1.7 中引入的，可以方便利用多核平台的计算能力，简化并行程序的编写，开发人员仅需关注如何划分任务和组合中间结果；</p>
</li>
<li><p>TimeUnit 枚举，TimeUnit 是 java.util.concurrent 包下面的一个枚举类，TimeUnit 提供了可读性更好的线程暂停操作，以及方便的时间单位转换方法；</p>
<p><img src="https://gitee.com/dingdang0/images/raw/master/img/2021/spring/20210305091052.png" alt="image-20210131211909379"></p>
</li>
</ul>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p><img src="https://gitee.com/dingdang0/images/raw/master/img/2021/spring/20210305091053.png" alt="img"></p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>CAS在 <strong>先比较后修改</strong> 这个CAS过程中，根本没有获取锁，释放锁的操作，是硬件层面的原子操作，跟JMM内存模型没有关系。大家可以理解为直接使用其他的语言，在JVM虚拟机之外直接操作计算机硬件，正因为如此，对比synchronized的同步，少了很多的逻辑步骤，使得性能大为提高。</p>
<p>JUC下的atomic类都是通过CAS来实现的，下面就是一个AtomicInteger原子操作类的例子，在其中使用了Unsafe unsafe = Unsafe.getUnsafe()。Unsafe 是CAS的核心类，它提供了硬件级别的原子操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//操作的值也进行了volatile修饰，保证内存可见性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure>

<p>继续查看AtomicInteger的addAndGet()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta) + delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其内部调用unsafe的getAndAddInt方法，查看看compareAndSwapInt方法，该方法为native方法，有四个参数，分别代表：对象、对象的地址、预期值、修改值。：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure>

<p>Unsafe 是一个比较危险的类，主要是用于执行低级别、不安全的方法集合。尽管这个类和所有的方法都是公开的（public），但是这个类的使用仍然受限，你无法在自己的java程序中直接使用该类，因为只有授信的代码才能获得该类的实例。</p>
<h4 id="native关键词"><a href="#native关键词" class="headerlink" title="native关键词"></a>native关键词</h4><p>现。使用时，通过native关键字告诉JVM这个方法是在外部定义的。但JVM也不知道去哪找这个原生方法，此时需要通过javah命令生成.h文件。</p>
<p>示例步骤(c语言为例)：</p>
<ol>
<li><p>javac生成.class文件，比如javac NativePeer.java</p>
</li>
<li><p>javah生成.h文件，比如javah NativePeer</p>
</li>
<li><p>编写c语言文件，在其中include进上一步生成的.h文件，然后实现其中声明而未实现的函数</p>
</li>
<li><p>生成dll共享库，然后Java程序load库，调用即可</p>
<p>native可以和任何除abstract外的关键字连用，这也说明了这些方法是有实体的，并且能够和其他Java方法一样，拥有各种Java的特性。</p>
</li>
</ol>
<h4 id="多CPU的CAS处理"><a href="#多CPU的CAS处理" class="headerlink" title="多CPU的CAS处理"></a>多CPU的CAS处理</h4><blockquote>
<p>总线加锁，缓存加锁</p>
</blockquote>
<h4 id="CAS缺陷"><a href="#CAS缺陷" class="headerlink" title="CAS缺陷"></a>CAS缺陷</h4><p>CAS虽然高效地解决了原子操作，但是还是存在一些缺陷的，主要表现在三个方法：循环时间太长、只能保证一个共享变量原子操作、ABA问题。</p>
<ul>
<li><p><strong>循环时间太长</strong></p>
<p>如果CAS一直不成功呢？这种情况绝对有可能发生，如果自旋CAS长时间地不成功，则会给CPU带来非常大的开销。在JUC中有些地方就限制了CAS自旋的次数，例如BlockingQueue的SynchronousQueue。</p>
</li>
<li><p><strong>只能保证一个共享变量原子操作</strong></p>
<p>看了CAS的实现就知道这只能针对一个共享变量，如果是多个共享变量就只能使用锁了。</p>
</li>
<li><p><strong>ABA问题</strong></p>
<p>CAS需要检查操作值有没有发生改变，如果没有发生改变则更新。但是存在这样一种情况：如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的ABA问题。对于ABA问题其解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加1，即A —&gt; B —&gt; A，变成1A —&gt; 2B —&gt; 3A。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CAS的ABA隐患问题，Java提供了AtomicStampedReference来解决。AtomicStampedReference通过包装[E,Integer]的元组来对对象标记版本戳stamp，从而避免ABA问题。对于上面的案例应该线程1会失败。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><img src="https://gitee.com/dingdang0/images/raw/master/img/2021/spring/20210305091054.png" alt="image-20210131212846289" style="zoom:80%;" />

<blockquote>
<p>AtomicInteger的工作原理，它们的内部都维护者一个对应的基本类型的成员变量value，这个变量是被volatile关键字修饰的，保证多线程环境下看见的是同一个（可见性）。AtomicInteger在进行一些原子操作的时候，依赖Unsafe类里面的CAS方法，原子操作就是通过自旋方式，不断地使用CAS函数进行尝试直到达到自己的目的。</p>
</blockquote>
<h4 id="atomic里的类主要包括："><a href="#atomic里的类主要包括：" class="headerlink" title="atomic里的类主要包括："></a>atomic里的类主要包括：</h4><ul>
<li><p>基本类型 使用原子的方式更新基本类型</p>
<blockquote>
<p>AtomicInteger：整形原子类 AtomicLong：长整型原子类 AtomicBoolean ：布尔型原子类</p>
</blockquote>
</li>
<li><p>引用类型</p>
<blockquote>
<p>AtomicReference：引用类型原子类 AtomicStampedReference：原子更新引用类型里的字段原子类 AtomicMarkableReference ：原子更新带有标记位的引用类型</p>
</blockquote>
</li>
<li><p>数组类型 使用原子的方式更新数组里的某个元素</p>
<blockquote>
<p>AtomicIntegerArray：整形数组原子类 AtomicLongArray：长整形数组原子类 AtomicReferenceArray ：引用类型数组原子类</p>
</blockquote>
</li>
<li><p>对象的属性修改类型</p>
<blockquote>
<p>AtomicIntegerFieldUpdater:原子更新整形字段的更新器 AtomicLongFieldUpdater：原子更新长整形字段的更新器 AtomicReferenceFieldUpdater ：原子更新引用类形字段的更新器</p>
</blockquote>
</li>
<li><p>JDK1.8新增类</p>
<blockquote>
<p>DoubleAdder：双浮点型原子类 LongAdder：长整型原子类 DoubleAccumulator：类似DoubleAdder，但要更加灵活(要传入一个函数式接口) LongAccumulator：类似LongAdder，但要更加灵活(要传入一个函数式接口)</p>
</blockquote>
</li>
</ul>
<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型:"></a>基本类型:</h4><p>AtomicInteger主要API如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">get()               <span class="comment">//直接返回值</span></span><br><span class="line">getAndAdd(<span class="keyword">int</span>)      <span class="comment">//增加指定的数据，返回变化前的数据</span></span><br><span class="line">getAndDecrement()   <span class="comment">//减少1，返回减少前的数据</span></span><br><span class="line">getAndIncrement()   <span class="comment">//增加1，返回增加前的数据</span></span><br><span class="line">getAndSet(<span class="keyword">int</span>)      <span class="comment">//设置指定的数据，返回设置前的数据</span></span><br><span class="line"></span><br><span class="line">addAndGet(<span class="keyword">int</span>)      <span class="comment">//增加指定的数据后返回增加后的数据</span></span><br><span class="line">decrementAndGet()   <span class="comment">//减少1，返回减少后的值</span></span><br><span class="line">incrementAndGet()   <span class="comment">//增加1，返回增加后的值</span></span><br><span class="line">lazySet(<span class="keyword">int</span>)        <span class="comment">//仅仅当get时才会set</span></span><br><span class="line"></span><br><span class="line">compareAndSet(<span class="keyword">int</span>, <span class="keyword">int</span>)<span class="comment">//尝试新增后对比，若增加成功则返回true否则返回false</span></span><br></pre></td></tr></table></figure>

<p>AtomicLong主要API和AtomicInteger，只是类型不是int，而是long</p>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><blockquote>
<p>AtomicReference：引用类型原子类 AtomicStampedRefrence：原子更新引用类型里的字段原子类 AtomicMarkableReference ：原子更新带有标记位的引用类型</p>
</blockquote>
<p>AtomicStampedReference其实它仅仅是在AtomicReference类的再一次包装，里面增加了一层引用和计数器，其实是否为计数器完全由自己控制，大多数我们是让他自增的，你也可以按照自己的方式来标示版本号。案例参考前面的ABA例子 </p>
<p>AtomicMarkableReference和AtomicStampedReference功能差不多，区别的是：它描述更加简单的是与否的关系。通常ABA问题只有两种状态，而AtomicStampedReference是多种状态。</p>
<h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>使用原子的方式更新数组里的某个元素</p>
<blockquote>
<p>AtomicIntegerArray：整形数组原子类 AtomicLongArray：长整形数组原子类 AtomicReferenceArray ：引用类型数组原子类</p>
</blockquote>
<h4 id="对象的属性修改类型"><a href="#对象的属性修改类型" class="headerlink" title="对象的属性修改类型"></a>对象的属性修改类型</h4><p>如果需要原子更新某个类里的某个字段时，需要用到对象的属性修改类型原子类。</p>
<blockquote>
<p>AtomicIntegerFieldUpdater:原子更新整形字段的更新器 AtomicLongFieldUpdater：原子更新长整形字段的更新器 AtomicReferenceFieldUpdater ：原子更新引用类形字段的更新器</p>
</blockquote>
<p>但是他们的使用通常有以下几个限制：</p>
<ul>
<li>限制1：操作的目标不能是static类型，前面说到的unsafe提取的是非static类型的属性偏移量，如果是static类型在获取时如果没有使用对应的方法是会报错的，而这个Updater并没有使用对应的方法。</li>
<li>限制2：操作的目标不能是final类型的，因为final根本没法修改。</li>
<li>限制3：必须是volatile类型的数据，也就是数据本身是读一致的。</li>
<li>限制4：属性必须对当前的Updater所在的区域是可见的，也就是private如果不是当前类肯定是不可见的，protected如果不存在父子关系也是不可见的，default如果不是在同一个package下也是不可见的。</li>
</ul>
<p>实现方式：通过反射找到属性，对属性进行操作。</p>
<h4 id="JDK1-8新增类"><a href="#JDK1-8新增类" class="headerlink" title="JDK1.8新增类"></a>JDK1.8新增类</h4><blockquote>
<p>LongAdder：长整型原子类 DoubleAdder：双浮点型原子类 LongAccumulator：类似LongAdder，但要更加灵活(要传入一个函数式接口) DoubleAccumulator：类似DoubleAdder，但要更加灵活(要传入一个函数式接口)</p>
</blockquote>
<p>LongAdder是jdk1.8提供的累加器，基于Striped64实现，所提供的API基本上可以替换原先的AtomicLong。</p>
<p>LongAdder类似于AtomicLong是原子性递增或者递减类，AtomicLong已经通过CAS提供了非阻塞的原子性操作，相比使用阻塞算法的同步器来说性能已经很好了，但是JDK开发组并不满足，因为在非常高的并发请求下AtomicLong的性能不能让他们接受，虽然AtomicLong使用CAS但是CAS失败后还是通过无限循环的自旋锁不断尝试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">long</span> current = get();</span><br><span class="line">        <span class="keyword">long</span> next = current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在高并发下N多线程同时去操作一个变量会造成大量线程CAS失败然后处于自旋状态，这大大浪费了cpu资源，降低了并发性。那么既然AtomicLong性能由于过多线程同时去竞争一个变量的更新而降低的，那么如果把一个变量分解为多个变量，让同样多的线程去竞争多个资源那么性能问题不就解决了？是的，JDK8提供的LongAdder就是这个思路。下面通过图形来标示两者不同。</p>
 <img src="https://gitee.com/dingdang0/images/raw/master/img/2021/spring/20210305091055" alt="img" style="zoom:80%;" />

<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>Java的内置锁一直都是备受争议的，在JDK 1.6之前，synchronized这个重量级锁其性能一直都是较为低下，虽然在1.6后，进行大量的锁优化策略，但是与Lock相比synchronized还是存在一些缺陷的：它缺少了获取锁与释放锁的可操作性，可中断、超时获取锁，而且独占式在高并发场景下性能大打折扣。</p>
<p>AQS解决了实现同步器时涉及到的大量细节问题，例如获取同步状态、FIFO同步队列。基于AQS来构建同步器可以带来很多好处。它不仅能够极大地减少实现工作，而且也不必处理在多个位置上发生的竞争问题。</p>
<h4 id="state状态"><a href="#state状态" class="headerlink" title="state状态"></a>state状态</h4><p>AQS维护了一个volatile int类型的变量state表示当前同步状态。当state&gt;0时表示已经获取了锁，当state = 0时表示释放了锁。</p>
<p>它提供了三个方法来对同步状态state进行操作：</p>
<blockquote>
<p>getState()：返回同步状态的当前值 setState()：设置当前同步状态 compareAndSetState()：使用CAS设置当前状态，该方法能够保证状态设置的原子性</p>
</blockquote>
<p>这三种操作均是CAS原子操作，其中compareAndSetState的实现依赖于Unsafe的compareAndSwapInt()方法</p>
<h4 id="资源共享方式"><a href="#资源共享方式" class="headerlink" title="资源共享方式"></a>资源共享方式</h4><p>AQS定义两种资源共享方式：</p>
<ul>
<li>Exclusive（独占，只有一个线程能执行，如ReentrantLock）</li>
<li>Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）</li>
</ul>
<h4 id="CLH同步队列"><a href="#CLH同步队列" class="headerlink" title="CLH同步队列"></a>CLH同步队列</h4><p>AQS内部维护着一个FIFO队列，该队列就是CLH同步队列，遵循FIFO原则（ First Input First Output先进先出）。CLH同步队列是一个FIFO双向队列，AQS依赖它来完成同步状态的管理。</p>
<p><img src="https://gitee.com/dingdang0/images/raw/master/img/2021/spring/20210305091056.png" alt="img"></p>
<p>当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。</p>
<p>CLH队列入列非常简单，就是tail指向新节点、新节点的prev指向当前最后的节点，当前最后一个节点的next指向当前节点。</p>
<p>代码我们可以看看addWaiter(Node node)方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新建Node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">//快速尝试添加尾节点</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//CAS设置尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//多次尝试</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中，两个方法都是通过一个CAS方法compareAndSetTail(Node expect, Node update)来设置尾节点，该方法可以确保节点是线程安全添加的。在enq(Node node)方法中，AQS通过“死循环”的方式来保证节点可以正确添加，只有成功添加后，当前线程才会从该方法返回，否则会一直执行下去。</p>
<p>CLH同步队列遵循FIFO，首节点的线程释放同步状态后，将会唤醒它的后继节点（next），而后继节点将会在获取同步状态成功时将自己设置为首节点。head执行该节点并断开原首节点的next和当前节点的prev即可，注意在这个过程是不需要使用CAS来保证的，因为只有一个线程能够成功获取到同步状态</p>
<h3 id="J-U-C之锁"><a href="#J-U-C之锁" class="headerlink" title="J.U.C之锁"></a>J.U.C之锁</h3><h4 id="1-锁的基本概念"><a href="#1-锁的基本概念" class="headerlink" title="1.锁的基本概念"></a>1.锁的基本概念</h4><p>虽然在前面锁优化的部分已经提到过一些锁的概念，但不完全，这里是对锁的概念补充。</p>
<h5 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5><blockquote>
<p>synchronized,ReentrantLock</p>
</blockquote>
<p>在编程中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。每个对象都对应于一个可称为” 互斥锁” 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。</p>
<h5 id="阻塞锁"><a href="#阻塞锁" class="headerlink" title="阻塞锁"></a>阻塞锁</h5><blockquote>
<p>sleep(),wait()</p>
</blockquote>
<p>阻塞锁，可以说是让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间） 时，才可以进入线程的准备就绪状态，准备就绪状态的所有线程，通过竞争，进入运行状态。</p>
<h5 id="自旋锁-1"><a href="#自旋锁-1" class="headerlink" title="自旋锁"></a>自旋锁</h5><blockquote>
<p>CAS</p>
</blockquote>
<p>自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时，才能进入临界区。</p>
<p>由于自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。如果线程竞争不激烈，并且保持锁的时间段。适合使用自旋锁。</p>
<h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><p>读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。</p>
<p>读写锁相对于自旋锁而言，能提高并发性，因为在多处理器系统中，它允许同时有多个读者来访问共享资源，最大可能的读者数为实际的逻辑CPU数。写者是排他性的，一个读写锁同时只能有一个写者或多个读者（与CPU数相关），但不能同时既有读者又有写者。</p>
<h5 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h5><p>公平锁（Fair）：加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得</p>
<p>非公平锁（Nonfair）：加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待</p>
<p>非公平锁性能比公平锁高，因为公平锁需要在多核的情况下维护一个队列。</p>
<h4 id="2-ReentrantLock"><a href="#2-ReentrantLock" class="headerlink" title="2. ReentrantLock"></a>2. ReentrantLock</h4><blockquote>
<p>ReentrantLock，可重入锁，是一种递归无阻塞的同步机制。它可以等同于synchronized的使用，但是ReentrantLock提供了比synchronized更强大、灵活的锁机制，可以减少死锁发生的概率。</p>
<p>ReentrantLock还提供了公平锁和非公平锁的选择，构造方法接受一个可选的公平参数（默认非公平锁），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高，在许多线程访问的情况下，公平锁表现出较低的吞吐量。</p>
</blockquote>
<h5 id="公平锁与非公平锁原理"><a href="#公平锁与非公平锁原理" class="headerlink" title="公平锁与非公平锁原理"></a>公平锁与非公平锁原理</h5><p>公平锁与非公平锁的区别在于获取锁的时候是否按照FIFO的顺序来。释放锁不存在公平性和非公平性，比较非公平锁和公平锁获取同步状态的过程，会发现两者唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()，定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">    Node t = tail;  //尾节点</span><br><span class="line">    Node h = head;  //头节点</span><br><span class="line">    Node s;</span><br><span class="line"></span><br><span class="line">    //头节点 != 尾节点</span><br><span class="line">    //同步队列第一个节点不为null</span><br><span class="line">    //当前线程是同步队列第一个节点</span><br><span class="line">    return h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == null || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要做一件事情：主要是判断当前线程是否位于CLH同步队列中的第一个。如果是则返回true，否则返回false。</p>
<h5 id="ReentrantLock与synchronized的区别"><a href="#ReentrantLock与synchronized的区别" class="headerlink" title="ReentrantLock与synchronized的区别"></a>ReentrantLock与synchronized的区别</h5><p>前面提到ReentrantLock提供了比synchronized更加灵活和强大的锁机制，那么它的灵活和强大之处在哪里呢？他们之间又有什么相异之处呢？</p>
<ol>
<li>与synchronized相比，ReentrantLock提供了更多，更加全面的功能，具备更强的扩展性。例如：时间锁等候，可中断锁等候，锁投票。</li>
<li>ReentrantLock还提供了条件Condition，对线程的等待、唤醒操作更加详细和灵活，所以在多个条件变量和高度竞争锁的地方，ReentrantLock更加适合（以后会阐述Condition）。</li>
<li>ReentrantLock提供了可轮询的锁请求。它会尝试着去获取锁，如果成功则继续，否则可以等到下次运行时处理，而synchronized则一旦进入锁请求要么成功要么阻塞，所以相比synchronized而言，ReentrantLock会不容易产生死锁些。</li>
<li>ReentrantLock支持更加灵活的同步代码块，但是使用synchronized时，只能在同一个synchronized块结构中获取和释放。注：ReentrantLock的锁释放一定要在finally中处理，否则可能会产生严重的后果。</li>
<li>ReentrantLock支持中断处理，且性能较synchronized会好些。</li>
</ol>
<h4 id="3-读写锁ReentrantReadWriteLock"><a href="#3-读写锁ReentrantReadWriteLock" class="headerlink" title="3. 读写锁ReentrantReadWriteLock"></a>3. 读写锁ReentrantReadWriteLock</h4><p>读写锁维护着一对锁，一个读锁和一个写锁。通过分离读锁和写锁，使得并发性比一般的互斥锁有了较大的提升：在同一时间可以允许多个读线程同时访问，但是在写线程访问时，所有读线程和写线程都会被阻塞。</p>
<p>读写锁的主要特性：</p>
<ol>
<li>公平性：支持公平性和非公平性。</li>
<li>重入性：支持重入。读写锁最多支持65535个递归写入锁和65535个递归读取锁。</li>
<li>锁降级：写锁能够降级成为读锁，遵循获取写锁、获取读锁在释放写锁的次序。读锁不能升级为写锁。</li>
</ol>
<p>ReentrantReadWriteLock与ReentrantLock一样，其锁主体依然是Sync，它的读锁、写锁都是依靠Sync来实现的。所以ReentrantReadWriteLock实际上只有一个锁，只是在获取读取锁和写入锁的方式上不一样而已，它的读写锁其实就是两个类：ReadLock、writeLock，这两个类都是lock实现。</p>
<p>在ReentrantLock中使用一个int类型的state来表示同步状态，该值表示锁被一个线程重复获取的次数。但是读写锁ReentrantReadWriteLock内部维护着一对锁，需要用一个变量维护多种状态。所以读写锁采用“按位切割使用”的方式来维护这个变量，将其切分为两部分，高16为表示读，低16为表示写。</p>
<h5 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h5><p>读写锁有一个特性就是锁降级，锁降级就意味着写锁是可以降级为读锁的。锁降级需要遵循以下顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">获取写锁=&gt;获取读锁=&gt;释放写锁</span><br></pre></td></tr></table></figure>

<h4 id="4-Condition介绍"><a href="#4-Condition介绍" class="headerlink" title="4. Condition介绍"></a>4. Condition介绍</h4><p>在没有Lock之前，我们使用synchronized来控制同步，配合Object的wait()、notify()系列方法可以实现等待/通知模式。在JDK5后，Java提供了Lock接口，相对于Synchronized而言，Lock提供了条件Condition，对线程的等待、唤醒操作更加详细和灵活。</p>
<p>下图是Condition与Object的监视器方法的对比：</p>
<p><img src="https://gitee.com/dingdang0/images/raw/master/img/2021/spring/20210305091057.png" alt="2018120815001"></p>
<p>Condition提供了一系列的方法来对阻塞和唤醒线程：</p>
<ol>
<li><p><strong>await()</strong> ：造成当前线程在接到信号或被中断之前一直处于等待状态。</p>
</li>
<li><p><strong>await(long time, TimeUnit unit)</strong> ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。</p>
</li>
<li><p><strong>awaitNanos(long nanosTimeout)</strong> ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。返回值表示剩余时间，如果在nanosTimesout之前唤醒，那么返回值 = nanosTimeout – 消耗时间，如果返回值 &lt;= 0 ,则可以认定它已经超时了。</p>
</li>
<li><p><strong>awaitUninterruptibly()</strong> ：造成当前线程在接到信号之前一直处于等待状态。【注意：该方法对中断不敏感】。</p>
</li>
<li><p><strong>awaitUntil(Date deadline)</strong> ：造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。如果没有到指定时间就被通知，则返回true，否则表示到了指定时间，返回返回false。</p>
</li>
<li><p>**signal()**：唤醒一个等待线程。该线程从等待方法返回前必须获得与Condition相关的锁。</p>
</li>
<li><p><strong>signal()All</strong>：唤醒所有等待线程。能够从等待方法返回的线程必须获得与Condition相关的锁。</p>
<p>Condition是一种广义上的条件队列（等待队列）。他为线程提供了一种更为灵活的等待/通知模式，线程在调用await方法后执行挂起操作，直到线程等待的某个条件为真时才会被唤醒。Condition必须要配合锁一起使用，因为对共享状态变量的访问发生在多线程环境下。一个Condition的实例必须与一个Lock绑定，因此Condition一般都是作为Lock的内部实现。</p>
</li>
</ol>
<h5 id="Condition的实现"><a href="#Condition的实现" class="headerlink" title="Condition的实现"></a>Condition的实现</h5><p>获取一个Condition必须通过Lock的newCondition()方法。该方法定义在接口Lock下面，返回的结果是绑定到此 Lock 实例的新 Condition 实例。Condition为一个接口，其下仅有一个实现类ConditionObject，由于Condition的操作需要获取相关的锁，而AQS则是同步锁的实现基础，所以ConditionObject则定义为AQS的内部类。定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class ConditionObject implements Condition, java.io.Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>等待队列</strong></li>
</ol>
<p>每个Condition对象都包含着一个FIFO队列，该队列是Condition对象通知/等待功能的关键。在队列中每一个节点都包含着一个线程引用，该线程就是在该Condition对象上等待的线程。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">//尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConditionObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 省略方法 **/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出Condition拥有首节点（firstWaiter），尾节点（lastWaiter）。当前线程调用await()方法，将会以当前线程构造成一个节点（Node），并将节点加入到该队列的尾部。</p>
<p>Node里面包含了当前线程的引用。Node定义与AQS的CLH同步队列的节点使用的都是同一个类（AbstractQueuedSynchronized.Node静态内部类）。</p>
<p>Condition的队列结构比CLH同步队列的结构简单些，新增过程较为简单只需要将原尾节点的nextWaiter指向新增节点，然后更新lastWaiter即可。</p>
<ol start="2">
<li><strong>等待状态</strong></li>
</ol>
<p>调用Condition的await()方法会使当前线程进入等待状态，同时会加入到Condition等待队列同时释放锁。当从await()方法返回时，当前线程一定是获取了Condition相关连的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 当前线程中断</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//当前线程加入等待队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    <span class="keyword">long</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检测此节点的线程是否在同步队上，如果不在，则说明该线程还不具备竞争锁的资格，则继续等待</span></span><br><span class="line"><span class="comment">         * 直到检测到此节点在同步队列上</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">//线程挂起</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//如果已经中断了，则退出</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//竞争同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="comment">//清理下条件队列中的不是在等待条件的节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此段代码的逻辑是：首先将当前线程新建一个节点同时加入到条件队列中，然后释放当前线程持有的同步状态。然后则是不断检测该节点代表的线程释放出现在CLH同步队列中（收到signal信号之后就会在AQS队列中检测到），如果不存在则一直挂起，否则参与竞争同步状态。</p>
<ol start="3">
<li><strong>通知</strong></li>
</ol>
<p>调用Condition的signal()方法，将会唤醒在等待队列中等待最长时间的节点（条件队列里的首节点），在唤醒节点前，会将节点移到CLH同步队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检测当前线程是否为拥有锁的独</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">//头节点，唤醒条件队列中的第一个节点</span></span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);    <span class="comment">//唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法首先会判断当前线程是否已经获得了锁，这是前置条件。然后唤醒等待队列中的头节点。</p>
<p>doSignal(Node first)：唤醒头节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//修改头结点，完成旧头结点的移出工作</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doSignal(Node first)主要是做两件事：</p>
<p>1.修改头节点，</p>
<p>2.调用transferForSignal(Node first) 方法将节点移动到CLH同步队列中。</p>
<h3 id="J-U-C之并发工具类"><a href="#J-U-C之并发工具类" class="headerlink" title="J.U.C之并发工具类"></a>J.U.C之并发工具类</h3><h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><blockquote>
<p>CyclicBarrier也叫同步屏障，在JDK1.5被引入的一个同步辅助类，在API中是这么介绍的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">允许一组线程全部等待彼此达到共同屏障点的同步辅助。 循环阻塞在涉及固定大小的线程方的程序中很有用，这些线程必须偶尔等待彼此。 屏障被称为循环，因为它可以在等待的线程被释放之后重新使用。</span><br></pre></td></tr></table></figure>

<p>CyclicBarrier好比一扇门，默认情况下关闭状态，堵住了线程执行的道路，直到所有线程都就位，门才打开，让所有线程一起通过。</p>
</blockquote>
<p><img src="https://gitee.com/dingdang0/images/raw/master/img/2021/spring/20210305091058.png" alt="image-20210205191927634"></p>
<ul>
<li>CyclicBarrier(int parties)：它将在给定数量的参与者（线程）处于等待状态时启动，但它不会在启动屏障时执行预定义的操作。parties表示拦截线程的数量。</li>
<li>CyclicBarrier(int parties, Runnable barrierAction) ：创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动屏障时执行给定的屏障操作，该操作由最后一个进入屏障的线程执行。</li>
</ul>
<p>在CyclicBarrier中最重要的方法莫过于await()方法，每个线程调用await方法告诉CyclicBarrier已经到达屏障位置，线程被阻塞。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>await()方法的逻辑：如果该线程不是到达的最后一个线程，则他会一直处于等待状态，除非发生以下情况：</p>
<ol>
<li>最后一个线程到达，即index == 0</li>
<li>超出了指定时间（超时等待）</li>
<li>其他的某个线程中断当前线程</li>
<li>其他的某个线程中断另一个等待的线程</li>
<li>其他的某个线程在等待屏障超时</li>
<li>其他的某个线程在此屏障调用reset()方法。reset()方法用于将屏障重置为初始状态。</li>
</ol>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>CountDownLatch是一个计数的闭锁，作用与CyclicBarrier有点儿相似。</p>
<p>在API中是这样描述的：</p>
<blockquote>
<p>用给定的计数 初始化 CountDownLatch。由于调用了 countDown() 方法，所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。</p>
<p>这种现象只出现一次——计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier。</p>
</blockquote>
<ul>
<li>CountDownLatch：一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；</li>
<li>CyclicBarrier：多个线程互相等待，直到到达同一个同步点，再继续一起执行。</li>
</ul>
<p>对于CountDownLatch来说，重点是“一个线程（多个线程）等待”，而其他的N个线程在完成“某件事情”之后，可以终止，也可以等待。而对于CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。</p>
<p>CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后就可以恢复等待的线程继续执行了。如下图</p>
<p><img src="https://gitee.com/dingdang0/images/raw/master/img/2021/spring/20210305091059.png" alt="img"></p>
<h5 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h5><p>CountDownLatch内部依赖Sync实现，而Sync继承AQS。CountDownLatch仅提供了一个构造方法：</p>
<p>CountDownLatch(int count) ： 构造一个用给定计数初始化的 CountDownLatch</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sync为CountDownLatch的一个内部类，通过这个内部类Sync可以知道CountDownLatch是采用共享锁来实现的。最长用的两个方法是await()和countDown()：</p>
<ul>
<li><p>CountDownLatch提供await()方法来使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。内部使用AQS的getState方法获取计数器，如果计数器值不等于0，则会以自旋方式会尝试一直去获取同步状态。</p>
</li>
<li><p>CountDownLatch提供countDown() 方法递减锁存器的计数，如果计数到达零，则释放所有等待的线程。内部调用AQS的releaseShared(int arg)方法来释放共享锁同步状态。</p>
</li>
</ul>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><blockquote>
<p>Semaphore是一个控制访问多个共享资源的计数器，和CountDownLatch一样，其本质上是一个“共享锁”。</p>
<p>Semaphore维护了一个信号量许可集。线程可以获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。 线程可以释放它所持有的信号量许可，被释放的许可归还到许可集中，可以被其他线程再次获取。</p>
</blockquote>
<p>信号量获取</p>
<hr>
<p>Semaphore提供了acquire()方法来获取一个许可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部使用AQS以共享模式获取同步状态，核心源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公平 判断该线程是否位于CLH队列的列头</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//判断该线程是否位于CLH队列的列头</span></span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//获取当前的信号量许可</span></span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置“获得acquires个信号量许可之后，剩余的信号量许可数”</span></span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CAS设置信号量</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非公平 对于非公平而言，因为它不需要判断当前线程是否位于CLH同步队列列头。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>信号量释放</p>
<hr>
<p>获取了许可，当用完之后就需要释放，Semaphore提供release()来释放许可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部调用AQS释放许可，核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="comment">//信号量的许可数 = 当前信号许可数 + 待释放的信号许可数</span></span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">//设置可获取的信号许可数为next</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="J-U-C队列"><a href="#J-U-C队列" class="headerlink" title="J.U.C队列"></a>J.U.C队列</h3><p>要实现一个线程安全的队列有两种方式：阻塞和非阻塞:</p>
<table>
<thead>
<tr>
<th align="left">queue</th>
<th align="left">阻塞与否</th>
<th align="left">是否有界</th>
<th align="left">线程安全保障</th>
<th align="left">适用场景</th>
<th align="left">注意事项</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ConcurrentLinkedQueue</td>
<td align="left">非阻塞</td>
<td align="left">无界</td>
<td align="left">CAS</td>
<td align="left">对全局的集合进行操作的场景</td>
<td align="left">size() 是要遍历一遍集合，慎用</td>
</tr>
<tr>
<td align="left">ArrayBlockingQueue</td>
<td align="left">阻塞</td>
<td align="left">有界</td>
<td align="left">一把全局锁</td>
<td align="left">生产消费模型，平衡两边处理速度</td>
<td align="left">–</td>
</tr>
<tr>
<td align="left">LinkedBlockingQueue</td>
<td align="left">阻塞</td>
<td align="left">可配置</td>
<td align="left">存取采用2把锁</td>
<td align="left">生产消费模型，平衡两边处理速度</td>
<td align="left">无界的时候注意内存溢出问题</td>
</tr>
<tr>
<td align="left">PriorityBlockingQueue</td>
<td align="left">阻塞</td>
<td align="left">无界</td>
<td align="left">一把全局锁</td>
<td align="left">支持优先级排序</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">SynchronousQueue</td>
<td align="left">阻塞</td>
<td align="left">无界</td>
<td align="left">CAS</td>
<td align="left">不存储元素的阻塞队列</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="非阻塞队列ConcurrentLinkedQueue"><a href="#非阻塞队列ConcurrentLinkedQueue" class="headerlink" title="非阻塞队列ConcurrentLinkedQueue"></a>非阻塞队列ConcurrentLinkedQueue</h4><p>在单线程编程中我们会经常用到一些集合类，比如ArrayList,HashMap等，但是这些类都不是线程安全的类。在面试中也经常会有一些考点，比如ArrayList不是线程安全的，Vector是线程安全。而保障Vector线程安全的方式，是非常粗暴的在方法上用synchronized独占锁，将多线程执行变成串行化。要想将ArrayList变成线程安全的也可以使用<code>Collections.synchronizedList(List&lt;T&gt; list)</code>方法ArrayList转换成线程安全的，但这种转换方式依然是通过synchronized修饰方法实现的，很显然这不是一种高效的方式，同时，队列也是我们常用的一种数据结构。</p>
<p>为了解决线程安全的问题，J.U.C为我们准备了ConcurrentLinkedQueue这个线程安全的队列。从类名就可以看的出来实现队列的数据结构是链式。ConcurrentLinkedQueue是一个基于链接节点的无边界的线程安全队列，遵循队列的FIFO原则，队尾入队，队首出队。采用CAS算法来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line"><span class="number">1.</span> ConcurrentLinkedQueue的.size() 是要遍历一遍集合的，很慢的，所以尽量要避免用size</span><br><span class="line"><span class="number">2.</span> 使用了这个ConcurrentLinkedQueue 类之后还是需要自己进行同步或加锁操作。例如queue.isEmpty()后再进行队列操作queue.add()是不能保证安全的，因为可能queue.isEmpty()执行完成后，别的线程开始操作队列。</span><br></pre></td></tr></table></figure>

<h4 id="阻塞队列BlockingQueue"><a href="#阻塞队列BlockingQueue" class="headerlink" title="阻塞队列BlockingQueue"></a>阻塞队列BlockingQueue</h4><h5 id="1-BlockingQueue接口"><a href="#1-BlockingQueue接口" class="headerlink" title="1. BlockingQueue接口"></a>1. BlockingQueue接口</h5><p>BlockingQueue即阻塞队列，从阻塞这个词可以看出，在某些情况下对阻塞队列的访问可能会造成阻塞。被阻塞的情况主要有如下两种：</p>
<ol>
<li>当队列满了的时候进行入队列操作</li>
<li>当队列空了的时候进行出队列操作</li>
</ol>
<p>因此，当一个线程试图对一个已经满了的队列进行入队列操作时，它将会被阻塞，除非有另一个线程做了出队列操作；同样，当一个线程试图对一个空队列进行出队列操作时，它将会被阻塞，除非有另一个线程进行了入队列操作。</p>
<p><img src="https://gitee.com/dingdang0/images/raw/master/img/2021/spring/20210305091100" alt="87"></p>
<p>BlockingQueue 对插入操作、移除操作、获取元素操作提供了四种不同的方法用于不同的场景中使用：</p>
<ol>
<li>抛出异常</li>
<li>返回特殊值（null 或 true/false，取决于具体的操作）</li>
<li>阻塞等待此操作，直到这个操作成功</li>
<li>阻塞等待此操作，直到成功或者超时指定时间。总结如下：</li>
</ol>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="left">抛出异常</th>
<th align="left">特殊值</th>
<th align="left">阻塞</th>
<th align="left">超时</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入</td>
<td align="left">add(e)</td>
<td align="left">offer(e)</td>
<td align="left">put(e)</td>
<td align="left">offer(e, time, unit)</td>
</tr>
<tr>
<td align="center">移除</td>
<td align="left">remove()</td>
<td align="left">poll()</td>
<td align="left">take()</td>
<td align="left">poll(time, unit)</td>
</tr>
<tr>
<td align="center">检查</td>
<td align="left">element()</td>
<td align="left">peek()</td>
<td align="left">不可用</td>
<td align="left">不可用</td>
</tr>
</tbody></table>
<p>接下来我们介绍这个接口的几个实现类。</p>
<h5 id="2-ArrayBlockingQueue"><a href="#2-ArrayBlockingQueue" class="headerlink" title="2. ArrayBlockingQueue"></a>2. ArrayBlockingQueue</h5><p>ArrayBlockingQueue是一个由数组实现的有界阻塞队列。该队列采用FIFO的原则对元素进行排序添加的。</p>
<p>ArrayBlockingQueue为有界且固定，其大小在构造时由构造函数来决定，确认之后就不能再改变了。</p>
<p>ArrayBlockingQueue支持对等待的生产者线程和使用者线程进行排序的可选公平策略，但是在默认情况下不保证线程公平的访问，在构造时可以选择公平策略（fair = true）。公平性通常会降低吞吐量，但是减少了可变性和避免了“不平衡性”。</p>
<p>ArrayBlockingQueue继承AbstractQueue，实现BlockingQueue接口。java.util.AbstractQueue，在Queue接口中扮演着非常重要的作用，该类提供了对queue操作的骨干实现。BlockingQueue继承java.util.Queue为阻塞队列的核心接口，提供了在多线程环境下的出列、入列操作，作为使用者，则不需要关心队列在什么时候阻塞线程，什么时候唤醒线程，所有一切均由BlockingQueue来完成。</p>
<p>ArrayBlockingQueue内部使用可重入锁ReentrantLock + Condition来完成多线程环境的并发操作。</p>
<ul>
<li>items，一个定长数组，维护ArrayBlockingQueue的元素</li>
<li>takeIndex，int，为ArrayBlockingQueue队首位置</li>
<li>putIndex，int，ArrayBlockingQueue队尾位置</li>
<li>count，元素个数</li>
<li>lock，锁，ArrayBlockingQueue出列入列都必须获取该锁，两个步骤公用一个锁</li>
</ul>
<h5 id="3-LinkedBlockingQueue"><a href="#3-LinkedBlockingQueue" class="headerlink" title="3. LinkedBlockingQueue"></a>3. LinkedBlockingQueue</h5><p>LinkedBlockingQueue和ArrayBlockingQueue的使用方式基本一样，但还是有一定的区别：</p>
<ol>
<li><p><strong>队列的数据结构不同</strong></p>
<p>ArrayBlockingQueue是一个由数组支持的有界阻塞队列</p>
<p>LinkedBlockingQueue是一个基于链表的有界（可设置）阻塞队列</p>
</li>
<li><p><strong>队列中锁的实现不同</strong></p>
</li>
</ol>
<p>ArrayBlockingQueue实现的队列中的锁是没有分离的，即生产和消费用的是同一个锁；</p>
<p>LinkedBlockingQueue实现的队列中的锁是分离的，即生产用的是putLock，消费是takeLock</p>
<ol start="3">
<li><strong>在生产或消费时操作不同</strong></li>
</ol>
<p>ArrayBlockingQueue实现的队列中在生产和消费的时候，是直接将枚举对象插入或移除的；</p>
<p>LinkedBlockingQueue实现的队列中在生产和消费的时候，需要把枚举对象转换为Node进行插入或移除，会影响性能</p>
<ol start="4">
<li><strong>队列大小初始化方式不同</strong></li>
</ol>
<p>ArrayBlockingQueue实现的队列中必须指定队列的大小；</p>
<p>LinkedBlockingQueue实现的队列中可以不指定队列的大小，但是默认是Integer.MAX_VALUE</p>
<h5 id="3-PriorityBlockingQueue"><a href="#3-PriorityBlockingQueue" class="headerlink" title="3. PriorityBlockingQueue"></a>3. PriorityBlockingQueue</h5><p>PriorityBlockingQueue类似于ArrayBlockingQueue内部使用一个独占锁来控制，同时只有一个线程可以进行入队和出队。</p>
<p>PriorityBlockingQueue是一个优先级队列，它在java.util.PriorityQueue的基础上提供了可阻塞的读取操作。它是无界的，就是说向Queue里面增加元素没有数量限制，但可能会导致内存溢出而失败。</p>
<p>　　PriorityBlockingQueue始终保证出队的元素是优先级最高的元素，并且可以定制优先级的规则，内部使用二叉堆，通过使用一个二叉树最小堆算法来维护内部数组，这个数组是可扩容的，当当前元素个数&gt;=最大容量时候会通过算法扩容。值得注意的是为了避免在扩容操作时候其他线程不能进行出队操作，实现上使用了先释放锁，然后通过CAS保证同时只有一个线程可以扩容成功。</p>
<p>小结：</p>
<p>1、优先队列不允许空值，而且不支持non-comparable（不可比较）的对象，比如用户自定义的类。优先队列要求使用Java Comparable和Comparator接口给对象排序，并且在排序时会按照优先级处理其中的元素。</p>
<p>2、优先队列的头是基于自然排序或者Comparator排序的最小元素。如果有多个对象拥有同样的排序，那么就可能随机地取其中任意一个。也可以通过提供的Comparator（比较器）在队列实现自定的排序。当我们获取队列时，返回队列的头对象。</p>
<p>3、优先队列的大小是不受限制的，但在创建时可以指定初始大小，当我们向优先队列增加元素的时候，队列大小会自动增加。</p>
<p>4、PriorityQueue是非线程安全的，所以Java提供了PriorityBlockingQueue（实现BlockingQueue接口）用于Java多线程环境。</p>
<h5 id="4-SynchronousQueue"><a href="#4-SynchronousQueue" class="headerlink" title="4. SynchronousQueue"></a>4. SynchronousQueue</h5><p>SynchronousQueue，实际上它不是一个真正的队列，因为它不会为队列中元素维护存储空间。与其他队列不同的是，它维护一组线程，这些线程在等待着把元素加入或移出队列。SynchronousQueue没有存储功能，因此put和take会一直阻塞，直到有另一个线程已经准备好参与到交付过程中。</p>
<p>仅当有足够多的消费者，并且总是有一个消费者准备好获取交付的工作时，才适合使用同步队列。这种实现队列的方式看似很奇怪，但由于可以直接交付工作，从而降低了将数据从生产者移动到消费者的延迟。</p>
<p>直接交付方式还会将更多关于任务状态的信息反馈给生产者。当交付被接受时，它就知道消费者已经得到了任务，而不是简单地把任务放入一个队列——这种区别就好比将文件直接交给同事，还是将文件放到她的邮箱中并希望她能尽快拿到文件。</p>
<p>SynchronousQueue对于正在等待的生产者和使用者线程而言，默认是非公平排序，也可以选择公平排序策略。但是，使用公平所构造的队列可保证线程以 FIFO 的顺序进行访问。 公平通常会降低吞吐量，但是可以减小可变性并避免得不到服务。</p>
<p>SynchronousQueue特点：</p>
<ul>
<li>是一种阻塞队列，其中每个 put 必须等待一个 take，反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。</li>
<li>是线程安全的，是阻塞的。</li>
<li>不允许使用 null 元素。</li>
<li>公平排序策略是指调用put的线程之间，或take的线程之间的线程以 FIFO 的顺序进行访问。</li>
<li>SynchronousQueue的方法：<ul>
<li>iterator()： 永远返回空，因为里面没东西。</li>
<li>peek() ：永远返回null。</li>
<li>put() ：往queue放进去一个element以后就一直wait直到有其他thread进来把这个element取走。</li>
<li>offer() ：往queue里放一个element后立即返回，如果碰巧这个element被另一个thread取走了，offer方法返回true，认为offer成功；否则返回false。</li>
<li>offer(2000, TimeUnit.SECONDS) ：往queue里放一个element但等待时间后才返回，和offer()方法一样。</li>
<li>take() ：取出并且remove掉queue里的element，取不到东西他会一直等。</li>
<li>poll() ：取出并且remove掉queue里的element，方法立即能取到东西返回。否则立即返回null。</li>
<li>poll(2000, TimeUnit.SECONDS) ：等待时间后再取，并且remove掉queue里的element,</li>
<li>isEmpty()：永远是true。</li>
<li>remainingCapacity() ：永远是0。</li>
<li>remove()和removeAll() ：永远是false。</li>
</ul>
</li>
</ul>
<h3 id="J-U-C线程池"><a href="#J-U-C线程池" class="headerlink" title="J.U.C线程池"></a>J.U.C线程池</h3><p>线程池好处：</p>
<ol>
<li>降低资源消耗：通过重用已经创建的线程来降低线程创建和销毁的消耗</li>
<li>提高响应速度：任务到达时不需要等待线程创建就可以立即执行。</li>
<li>提高线程的可管理性：线程池可以统一管理、分配、调优和监控。</li>
</ol>
<blockquote>
<p>java的线程池支持主要通过ThreadPoolExecutor来实现，我们使用的ExecutorService的各种线程池策略都是基于ThreadPoolExecutor实现的，所以ThreadPoolExecutor十分重要。要弄明白各种线程池策略，必须先弄明白ThreadPoolExecutor。</p>
</blockquote>
<p><img src="https://gitee.com/dingdang0/images/raw/master/img/2021/spring/20210305091101.png" alt="image-20210207105330530"></p>
<h4 id="ThreadPoolExecutor分析"><a href="#ThreadPoolExecutor分析" class="headerlink" title="ThreadPoolExecutor分析"></a>ThreadPoolExecutor分析</h4><h5 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h5><p>线程池同样有五种状态：Running, SHUTDOWN, STOP, TIDYING, TERMINATED。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;<span class="comment">//对应的高3位值是111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;<span class="comment">//对应的高3位值是000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;<span class="comment">//对应的高3位值是001</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;<span class="comment">//对应的高3位值是010</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;<span class="comment">//对应的高3位值是011</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<p>变量<strong>ctl</strong>定义为AtomicInteger ，记录了“线程池中的任务数量”和“线程池的状态”两个信息。共32位，其中高3位表示”线程池状态”，低29位表示”线程池中的任务数量”。</p>
<ul>
<li><p>RUNNING：处于RUNNING状态的线程池能够接受新任务，以及对新添加的任务进行处理。</p>
</li>
<li><p>SHUTDOWN：处于SHUTDOWN状态的线程池不可以接受新任务，但是可以对已添加的任务进行处理。</p>
</li>
<li><p>STOP：处于STOP状态的线程池不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。</p>
</li>
<li><p>TIDYING：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。</p>
</li>
<li><p>TERMINATED：线程池彻底终止的状态。</p>
</li>
</ul>
<p>各个状态的转换如下：</p>
<p><img src="https://gitee.com/dingdang0/images/raw/master/img/2021/spring/20210305091102.png" alt="img"></p>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>我现在分析线程池参数最全的构造方法，了解其内部的参数意义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;= 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.acc = System.getSecurityManager() == null ?</span><br><span class="line">        null :</span><br><span class="line">    AccessController.getContext();</span><br><span class="line">    this.corePoolSize = corePoolSize;</span><br><span class="line">    this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    this.workQueue = workQueue;</span><br><span class="line">    this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory = threadFactory;</span><br><span class="line">    this.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>共有七个参数，每个参数含义如下：</p>
<ul>
<li><p>corePoolSize</p>
<p>线程池中核心线程的数量（也称为线程池的基本大小）。当提交一个任务时，线程池会新建一个线程来执行任务，直到当前线程数等于corePoolSize。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</p>
</li>
<li><p>maximumPoolSize</p>
<p>线程池中允许的最大线程数。线程池的阻塞队列满了之后，如果还有任务提交，如果当前的线程数小于maximumPoolSize，则会新建线程来执行任务。注意，如果使用的是无界队列，该参数也就没有什么效果了。</p>
</li>
<li><p>keepAliveTime</p>
<p>线程空闲的时间。线程的创建和销毁是需要代价的。线程执行完任务后不会立即销毁，而是继续存活一段时间：keepAliveTime。默认情况下，该参数只有在线程数大于corePoolSize时才会生效。</p>
</li>
<li><p>unit</p>
<p>keepAliveTime的单位。TimeUnit</p>
</li>
<li><p>workQueue</p>
<p>用来保存等待执行的任务的BlockQueue阻塞队列，等待的任务必须实现Runnable接口。选择如下：</p>
<blockquote>
<p>ArrayBlockingQueue：基于数组结构的有界阻塞队列，FIFO。 LinkedBlockingQueue：基于链表结构的有界阻塞队列，FIFO。 PriorityBlockingQueue：具有优先级别的阻塞队列。 SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</p>
</blockquote>
</li>
<li><p>threadFactory</p>
<p>用于设置创建线程的工厂。ThreadFactory的作用就是提供创建线程的功能的线程工厂。他是通过newThread()方法提供创建线程的功能，newThread()方法创建的线程都是“非守护线程”而且“线程优先级都是默认优先级”。</p>
</li>
<li><p>handler</p>
<p>RejectedExecutionHandler，线程池的拒绝策略。所谓拒绝策略，是指将任务添加到线程池中时，线程池拒绝该任务所采取的相应策略。当向线程池中提交任务时，如果此时线程池中的线程已经饱和了，而且阻塞队列也已经满了，则线程池会选择一种拒绝策略来处理该任务。</p>
<p>线程池提供了四种拒绝策略：</p>
<blockquote>
<p>AbortPolicy：直接抛出异常，默认策略； CallerRunsPolicy：用调用者所在的线程来执行任务； DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务； DiscardPolicy：直接丢弃任务； 当然我们也可以实现自己的拒绝策略，例如记录日志等等，实现RejectedExecutionHandler接口即可。</p>
</blockquote>
</li>
</ul>
<h4 id="四种线程池"><a href="#四种线程池" class="headerlink" title="四种线程池"></a>四种线程池</h4><blockquote>
<p>我们除了可以使用ThreadPoolExecutor自己根据实际情况创建线程池以外，Executor框架也提供了三种线程池，他们都可以通过工具类Executors来创建。</p>
<p>还有一种线程池ScheduledThreadPoolExecutor，它相当于提供了“延迟”和“周期执行”功能的ThreadPoolExecutor</p>
</blockquote>
<h5 id="1-FixedThreadPool"><a href="#1-FixedThreadPool" class="headerlink" title="1. FixedThreadPool"></a>1. FixedThreadPool</h5><p>FixedThreadPool是复用<strong>固定数量的线程</strong>处理一个<strong>共享的无边界队列</strong>，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>corePoolSize 和 maximumPoolSize都设置为创建FixedThreadPool时指定的参数nThreads，由于该线程池是固定线程数的线程池，当线程池中的线程数量等于corePoolSize 时，如果继续提交任务，该任务会被添加到阻塞队列workQueue中，而workQueue使用的是LinkedBlockingQueue，但没有设置范围，那么则是最大值（Integer.MAX_VALUE），这基本就相当于一个无界队列了。</p>
<img src="https://gitee.com/dingdang0/images/raw/master/img/2021/spring/20210305091103.png" alt="img" style="zoom:75%;" />

<h5 id="2-SingleThreadExecutor"><a href="#2-SingleThreadExecutor" class="headerlink" title="2. SingleThreadExecutor"></a>2. SingleThreadExecutor</h5><p>SingleThreadExecutor只会使用单个工作线程来执行一个无边界的队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为单一worker线程的线程池，它把corePool和maximumPoolSize均被设置为1，和FixedThreadPool一样使用的是无界队列LinkedBlockingQueue,所以带来的影响和FixedThreadPool一样。</p>
<p>SingleThreadExecutor只会使用单个工作线程，它可以保证认为是按顺序执行的，任何时候都不会有多于一个的任务处于活动状态。注意，如果单个线程在执行过程中因为某些错误中止，新的线程会替代它执行后续线程。</p>
<img src="https://gitee.com/dingdang0/images/raw/master/img/2021/spring/20210305091104.png" alt="img" style="zoom:75%;" />

<h5 id="3-CachedThreadPool"><a href="#3-CachedThreadPool" class="headerlink" title="3. CachedThreadPool"></a>3. CachedThreadPool</h5><p>CachedThreadPool会根据需要，在线程可用时，重用之前构造好的池中线程，否则创建新线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它把corePool为0，maximumPoolSize为Integer.MAX_VALUE，这就意味着所有的任务一提交就会加入到阻塞队列中。因为线程池的基本大小设置为0，一般情况下线程池中没有程池，用的时候再创建。</p>
<p>但是keepAliveTime设置60，unit设置为秒，意味着空闲线程等待新任务的最长时间为60秒，空闲线程超过60秒后将会被终止。阻塞队列采用的SynchronousQueue，这是是一个没有元素的阻塞队列。</p>
<p>这个线程池在执行 大量短生命周期的异步任务时，可以显著提高程序性能。调用 execute 时，可以重用之前已构造的可用线程，如果不存在可用线程，那么会重新创建一个新的线程并将其加入到线程池中。如果线程超过 60 秒还未被使用，就会被中止并从缓存中移除。因此，线程池在长时间空闲后不会消耗任何资源。</p>
<p>但是这样就处理线程池会存在一个问题，如果主线程提交任务的速度远远大于CachedThreadPool的处理速度，则CachedThreadPool会不断地创建新线程来执行任务，这样有可能会导致系统耗尽CPU和内存资源，所以在使用该线程池是，一定要注意控制并发的任务数，否则创建大量的线程可能导致严重的性能问题。</p>
<h5 id="4-ScheduledThreadPool"><a href="#4-ScheduledThreadPool" class="headerlink" title="4. ScheduledThreadPool"></a>4. ScheduledThreadPool</h5><p>Timer与TimerTask虽然可以实现线程的周期和延迟调度，但是Timer与TimerTask存在一些问题：</p>
<ul>
<li>Timer在执行定时任务时只会创建一个线程，所以如果存在多个任务，且任务时间过长，超过了两个任务的间隔时间，会发生一些缺陷。</li>
<li>如果TimerTask抛出RuntimeException，Timer会停止所有任务的运行。</li>
<li>Timer执行周期任务时依赖系统时间，如果当前系统时间发生变化会出现一些执行上的变化</li>
</ul>
<p>为了解决这些问题，我们一般都是推荐ScheduledThreadPoolExecutor来实现。</p>
<p>ScheduledThreadPoolExecutor，继承ThreadPoolExecutor且实现了ScheduledExecutorService接口，它就相当于提供了“延迟”和“周期执行”功能的ThreadPoolExecutor。</p>
<p>ScheduledThreadPoolExecutor，它可另行安排在给定的延迟后运行命令，或者定期执行命令。需要多个辅助线程时，或者要求 ThreadPoolExecutor 具有额外的灵活性或功能时，此类要优于Timer。</p>
<p>提供了四种构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">            <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">            <span class="keyword">new</span> DelayedWorkQueue(), threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">            <span class="keyword">new</span> DelayedWorkQueue(), handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">            <span class="keyword">new</span> DelayedWorkQueue(), threadFactory, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ScheduledThreadPoolExecutor的构造函数中，我们发现它都是利用ThreadLocalExecutor来构造的，唯一变动的地方就在于它所使用的阻塞队列变成了DelayedWorkQueue。</p>
<p>DelayedWorkQueue为ScheduledThreadPoolExecutor中的内部类，类似于延时队列和优先级队列。在执行定时任务的时候，每个任务的执行时间都不同，所以DelayedWorkQueue的工作就是按照执行时间的升序来排列，执行时间距离当前时间越近的任务在队列的前面，这样就可以保证每次出队的任务都是当前队列中执行时间最靠前的。</p>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo9ScheduledThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始：&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="comment">// 第二个参数是延迟多久执行</span></span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> Task(), <span class="number">0</span>, TimeUnit.SECONDS);</span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> Task(), <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> Task(), <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        scheduledThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String name = Thread.currentThread().getName();</span><br><span class="line"></span><br><span class="line">                System.out.println(name + <span class="string">&quot;, 开始：&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;, 结束：&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="J-U-C之并发容器ConcurrentHashMap"><a href="#J-U-C之并发容器ConcurrentHashMap" class="headerlink" title="J.U.C之并发容器ConcurrentHashMap"></a>J.U.C之并发容器ConcurrentHashMap</h3><h4 id="集合框架容器对应的并发容器"><a href="#集合框架容器对应的并发容器" class="headerlink" title="集合框架容器对应的并发容器"></a>集合框架容器对应的并发容器</h4><p>ArrayList 的线程安全类有：</p>
<ol>
<li>vector 或Collections.synchronizedList()  通过synchronized修饰方法实现</li>
<li>CopyOnWriteArrayList<E> 通过ReentrantLock实现</li>
<li>ConcurrentLinkedQueue CAS实现</li>
</ol>
<p>set 的线程安全类有：</p>
<ol>
<li>Collections.synchronizedSet()</li>
<li>CopyOnWriteArraySet<E> 通过ReentrantLock实现</li>
</ol>
<p>hashmap 线程安全类：</p>
<ol>
<li>hashtable 或 Collections.synchronizedMap() synchronized</li>
<li>ConcurrentHashMap CAS+Synchronized</li>
</ol>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><blockquote>
<p>HashMap是我们用得非常频繁的一个集合，但是它是线程不安全的。并且在多线程环境下，put操作是有可能产生死循环，不过在JDK1.8的版本中更换了数据插入的顺序，已经解决了这个问题。</p>
<p>为了解决该问题，提供了Hashtable和Collections.synchronizedMap(hashMap)两种解决方案，但是这两种方案都是对读写加锁，独占式。一个线程在读时其他线程必须等待，吞吐量较低，性能较为低下。而J.U.C给我们提供了高性能的线程安全HashMap：ConcurrentHashMap。</p>
<p>在1.8版本以前，ConcurrentHashMap采用分段锁的概念，使锁更加细化，但是1.8已经改变了这种思路，而是利用CAS+Synchronized来保证并发更新的安全，当然底层采用数组+链表+红黑树的存储结构。</p>
</blockquote>
<h4 id="JDK7-HashMap"><a href="#JDK7-HashMap" class="headerlink" title="JDK7 HashMap"></a>JDK7 HashMap</h4><p>HashMap 是最简单的，它不支持并发操作，下面这张图是 HashMap 的结构：</p>
<p><img src="https://gitee.com/dingdang0/images/raw/master/img/2021/spring/20210305091105.png" alt="1"></p>
<p>HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。</p>
<p><code>public HashMap(int initialCapacity, float loadFactor)</code>初始化方法的参数说明：</p>
<blockquote>
<p>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。 loadFactor：负载因子，默认为 0.75。 threshold：扩容的阈值，等于 capacity * loadFactor</p>
</blockquote>
<p><strong>put 过程</strong></p>
<ul>
<li>数组初始化，在第一个元素插入 HashMap 的时候做一次数组的初始化，先确定初始的数组大小，并计算数组扩容的阈值。</li>
<li>计算具体数组位置，使用key进行hash值计算，根据hash值计算应该放在哪个数组中。</li>
<li>找到数组下标后，会先进行 key 判断是否重复，如果没有重复，就准备将新值放入到链表的表头（在多线程操作中，这种操作会造成死循环，在jdk1.8已解决）。</li>
<li>数组扩容，在插入新值的时候，如果当前的 size 已经达到了阈值，并且要插入的数组位置上已经有元素，那么就会触发扩容，扩容后，数组大小为原来的 2 倍。扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。</li>
</ul>
<p><strong>get过程</strong></p>
<ul>
<li>根据 key 计算 hash 值。</li>
<li>根据hash值找到相应的数组下标。</li>
<li>遍历该数组位置处的链表，直到找到相等的 key。</li>
</ul>
<h4 id="JDK7-ConcurrentHashMap"><a href="#JDK7-ConcurrentHashMap" class="headerlink" title="JDK7 ConcurrentHashMap"></a>JDK7 ConcurrentHashMap</h4><p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。</p>
<p>整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多人都会将其描述为分段锁。简单的说，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的。</p>
<p>再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，每次操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的。</p>
<p><strong>初始化</strong></p>
<p><code>public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)</code>初始化方法</p>
<ul>
<li>initialCapacity：整个 ConcurrentHashMap 的初始容量，实际操作的时候需要平均分给每个 Segment。</li>
<li>concurrencyLevel：并发数(或者Segment 数，有很多叫法，重要的是如何理解)。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。</li>
<li>loadFactor：负载因子，Segment 数组不可以扩容，所以这个负载因子是给每个 Segment 内部使用的。</li>
</ul>
<p>举个简单的例子：</p>
<p>用 new ConcurrentHashMap() 无参构造函数进行初始化的，那么初始化完成后：</p>
<ul>
<li>Segment 数组长度为 16，不可以扩容</li>
<li>Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容</li>
<li>这里初始化了 segment[0]，其他位置还是 null，</li>
</ul>
<p><strong>put过程</strong></p>
<ul>
<li>根据 hash 值能找到相应的 Segment，之后就是 Segment 内部的 put 操作了。</li>
<li>Segment 内部是由 数组+链表 组成的，由于有独占锁的保护，所以 segment 内部的操作并不复杂。保证多线程安全的，就是做了一件事，那就是获取该 segment 的独占锁。</li>
<li>Segment 数组不能扩容，<strong>rehash方法</strong>扩容是 segment 数组某个位置内部的数组 HashEntry[] 进行扩容，扩容后，容量为原来的 2 倍。</li>
</ul>
<p><strong>get过程</strong></p>
<ul>
<li>计算 hash 值，找到 segment 数组中的具体位置</li>
<li>segment 数组中也是数组，再根据 hash 找到数组中具体值的位置</li>
<li>到这里是链表了，顺着链表进行查找即可</li>
</ul>
<h4 id="JDK8-HashMap"><a href="#JDK8-HashMap" class="headerlink" title="JDK8 HashMap"></a>JDK8 HashMap</h4><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。</p>
<p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度。</p>
<p>为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度。</p>
<p>jdk7 中使用 Entry 来代表每个 HashMap 中的数据节点，jdk8 中使用 Node，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。</p>
<p>我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。</p>
<p><strong>put过程</strong></p>
<p>和jdk7的put差不多</p>
<ul>
<li>和 Jdk7 不一样的地方就是，jdk7是先扩容后插入新值的，jdk8 先插值再扩容</li>
<li>先使用链表进行存放数据，当数量超过8个的时候，将链表转为红黑树</li>
</ul>
<p><strong>get 过程分析</strong></p>
<ol>
<li>计算 key 的 hash 值，根据 hash 值找到对应数组下标。</li>
<li>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步。</li>
<li>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步。</li>
<li>遍历链表，直到找到相等(==或equals)的 key。</li>
</ol>
<p><strong>JDK8 HashMap代码分析</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">   * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">   * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment">   * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment">   * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment">   * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment">   * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment">   * shrinkage.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment">   * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment">   * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment">   * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment">   * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment">   * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">//最小树形化容量阈值：即 当哈希表中的容量 &gt; 该值时，才允许树形化链表 （即 将链表 转换成红黑树）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 否则，若桶内元素太多时，则直接扩容，而不是树形化</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment">   * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">      <span class="keyword">final</span> K key;</span><br><span class="line">      V value;</span><br><span class="line">      Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">      Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">          <span class="keyword">this</span>.hash = hash;</span><br><span class="line">          <span class="keyword">this</span>.key = key;</span><br><span class="line">          <span class="keyword">this</span>.value = value;</span><br><span class="line">          <span class="keyword">this</span>.next = next;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h4 id="JDK8-ConcurrentHashMap"><a href="#JDK8-ConcurrentHashMap" class="headerlink" title="JDK8 ConcurrentHashMap"></a>JDK8 ConcurrentHashMap</h4><p>Java7 中实现的 ConcurrentHashMap 还是比较复杂的，Java8 对 ConcurrentHashMap 进行了比较大的改动。可以参考 Java8 中 HashMap 相对于 Java7 HashMap 的改动，对于 ConcurrentHashMap，Java8 也引入了红黑树。</p>
<p>在1.8版本以前，ConcurrentHashMap采用分段锁的概念，使锁更加细化，但是1.8已经改变了这种思路，而是利用CAS+Synchronized来保证并发更新的安全，底层采用数组+链表+红黑树的存储结构。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>ConcurrentHashMap通常只被看做并发效率更高的Map，用来替换其他线程安全的Map容器，比如Hashtable和Collections.synchronizedMap。线程安全的容器，特别是Map，很多情况下一个业务中涉及容器的操作有多个，即复合操作，而在并发执行时，线程安全的容器只能保证自身的数据不被破坏，和数据在多个线程间是可见的，但无法保证业务的行为是否正确。</p>
<p>ConcurrentHashMap总结：</p>
<ul>
<li>HashMap是线程不安全的，ConcurrentHashMap是线程安全的，但是线程安全仅仅指的是对容器操作的时候是线程安全的</li>
<li>ConcurrentHashMap的public V get(Object key)不涉及到锁，也就是说获得对象时没有使用锁</li>
<li>put、remove方法，在jdk7使用锁，但多线程中并不一定有锁争用，原因在于ConcurrentHashMap将缓存的变量分到多个Segment，每个Segment上有一个锁，只要多个线程访问的不是一个Segment就没有锁争用，就没有堵塞，各线程用各自的锁，ConcurrentHashMap缺省情况下生成16个Segment，也就是允许16个线程并发的更新而尽量没有锁争用。而在jdk8中使用的CAS+Synchronized来保证线程安全，比加锁的性能更高</li>
<li>ConcurrentHashMap线程安全的，允许一边更新、一边遍历，也就是说在对象遍历的时候，也可以进行remove,put操作，且遍历的数据会随着remove,put操作产出变化，</li>
</ul>
<h4 id="对比Hashtable"><a href="#对比Hashtable" class="headerlink" title="对比Hashtable"></a>对比Hashtable</h4><p>Hashtable和ConcurrentHashMap的不同点：</p>
<ul>
<li>Hashtable对get,put,remove都使用了同步操作，它的同步级别是正对Hashtable来进行同步的，也就是说如果有线程正在遍历集合，其他的线程就暂时不能使用该集合了，这样无疑就很容易对性能和吞吐量造成影响，从而形成单点。而ConcurrentHashMap则不同，它只对put,remove操作使用了同步操作，get操作并不影响。</li>
<li>Hashtable在遍历的时候，如果其他线程，包括本线程对Hashtable进行了put，remove等更新操作的话，就会抛出ConcurrentModificationException异常，但如果使用ConcurrentHashMap的话，就不用考虑这方面的问题了</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">dingdang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://dingdang0.github.io/2021/08/15/JUC%E7%9F%A5%E8%AF%86%E7%82%B9/">https://dingdang0.github.io/2021/08/15/JUC%E7%9F%A5%E8%AF%86%E7%82%B9/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://dingdang0.github.io" target="_blank">叮当园</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="post_share"><div class="social-share" data-image="https://api.mz-moe.cn/img.php" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/08/15/%E7%A7%BB%E5%8A%A8web%E5%BC%80%E5%8F%91/"><img class="prev-cover" src="https://api.mz-moe.cn/img.php" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">移动web开发</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/09/ajax/"><img class="next-cover" src="https://api.mz-moe.cn/img.php" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ajax</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/08/15/面试题/" title="多线程，mysql面试题"><img class="cover" src="https://api.ixiaowai.cn/gqapi/gqapi.php" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-15</div><div class="title">多线程，mysql面试题</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://portrait.gitee.com/uploads/avatars/user/2475/7426089_dingdang0_1593615956.png!avatar60" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">dingdang</div><div class="author-info__description">我不断努力，只是为了追上曾经的自己</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/dingdang0" target="_blank" title="Github"><i class="iconfont icon-git"></i></a><a class="social-icon" href="https://gitee.com/dingdang0" target="_blank" title="Gitee"><i class="iconfont icon-gitee"></i></a><a class="social-icon" href="https://mail.qq.com/" target="_blank" title="QQ邮箱"><i class="iconfont icon-QQyouxiang1"></i></a><a class="social-icon" href="https://www.csdn.net/" target="_blank" title="CSDN"><i class="iconfont icon-csdn"></i></a><a class="social-icon" href="https://www.cnblogs.com/dingdang0/" target="_blank" title="博客园"><i class="iconfont icon-cnblogs"></i></a><a class="social-icon" href="https://mail.163.com/" target="_blank" title="网易邮箱"><i class="iconfont icon-wangyi"></i></a><a class="social-icon" href="https://note.youdao.com/web/" target="_blank" title="有道云笔记"><i class="iconfont icon-youdaoyunbiji"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">多线程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">进程与线程的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.2.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%81%9C%E6%AD%A2"><span class="toc-number">1.3.</span> <span class="toc-text">线程停止</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.4.</span> <span class="toc-text">线程优先级</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6"><span class="toc-number">2.</span> <span class="toc-text">多线程进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.1.</span> <span class="toc-text">1. JVM内存结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Java%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.2.</span> <span class="toc-text">2. Java对象模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-JMM"><span class="toc-number">2.1.3.</span> <span class="toc-text">3. java内存模型(JMM)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98%E4%BE%8B%E5%AD%90"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">可见性问题例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized"><span class="toc-number">2.2.</span> <span class="toc-text">synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-synchronized%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.synchronized解决可见性过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">synchronized实现可见性的过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-synchronized%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.2.</span> <span class="toc-text">2. synchronized实现同步原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%94%81%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.3.</span> <span class="toc-text">相关锁概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">自旋锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">适应自旋锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-number">2.2.3.3.</span> <span class="toc-text">锁消除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96"><span class="toc-number">2.2.3.4.</span> <span class="toc-text">锁粗化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">2.2.3.5.</span> <span class="toc-text">偏向锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">2.2.3.6.</span> <span class="toc-text">轻量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E9%94%81"><span class="toc-number">2.2.3.7.</span> <span class="toc-text">重量锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Volatile"><span class="toc-number">2.3.</span> <span class="toc-text">Volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Volatile%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">Volatile实现内存可见性的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Volatile%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">2.3.2.</span> <span class="toc-text">Volatile实现内存可见性原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E6%9B%BFvolatile%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%80%A7%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.3.</span> <span class="toc-text">代替volatile实现原子性方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Volatile-%E9%80%82%E5%90%88%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.3.4.</span> <span class="toc-text">Volatile 适合使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%92%8Cvolatile%E6%AF%94%E8%BE%83"><span class="toc-number">2.3.5.</span> <span class="toc-text">synchronized和volatile比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JUC%E5%86%85%E5%AE%B9"><span class="toc-number">2.4.</span> <span class="toc-text">JUC内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#J-U-C-%E6%A1%86%E6%9E%B6%E5%8C%85%E5%90%AB%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">2.4.1.</span> <span class="toc-text">J.U.C 框架包含的内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS"><span class="toc-number">2.4.2.</span> <span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#native%E5%85%B3%E9%94%AE%E8%AF%8D"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">native关键词</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9ACPU%E7%9A%84CAS%E5%A4%84%E7%90%86"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">多CPU的CAS处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS%E7%BC%BA%E9%99%B7"><span class="toc-number">2.4.2.4.</span> <span class="toc-text">CAS缺陷</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Atomic"><span class="toc-number">2.4.3.</span> <span class="toc-text">Atomic</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#atomic%E9%87%8C%E7%9A%84%E7%B1%BB%E4%B8%BB%E8%A6%81%E5%8C%85%E6%8B%AC%EF%BC%9A"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">atomic里的类主要包括：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.3.3.</span> <span class="toc-text">基本类型:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.3.4.</span> <span class="toc-text">引用类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.3.5.</span> <span class="toc-text">数组类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BF%AE%E6%94%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.3.6.</span> <span class="toc-text">对象的属性修改类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-8%E6%96%B0%E5%A2%9E%E7%B1%BB"><span class="toc-number">2.4.3.7.</span> <span class="toc-text">JDK1.8新增类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS"><span class="toc-number">2.4.4.</span> <span class="toc-text">AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#state%E7%8A%B6%E6%80%81"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">state状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">资源共享方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CLH%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97"><span class="toc-number">2.4.4.3.</span> <span class="toc-text">CLH同步队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#J-U-C%E4%B9%8B%E9%94%81"><span class="toc-number">2.4.5.</span> <span class="toc-text">J.U.C之锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.4.5.1.</span> <span class="toc-text">1.锁的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">2.4.5.1.1.</span> <span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%94%81"><span class="toc-number">2.4.5.1.2.</span> <span class="toc-text">阻塞锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81-1"><span class="toc-number">2.4.5.1.3.</span> <span class="toc-text">自旋锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">2.4.5.1.4.</span> <span class="toc-text">读写锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">2.4.5.1.5.</span> <span class="toc-text">公平锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-ReentrantLock"><span class="toc-number">2.4.5.2.</span> <span class="toc-text">2. ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.5.2.1.</span> <span class="toc-text">公平锁与非公平锁原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ReentrantLock%E4%B8%8Esynchronized%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.5.2.2.</span> <span class="toc-text">ReentrantLock与synchronized的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock"><span class="toc-number">2.4.5.3.</span> <span class="toc-text">3. 读写锁ReentrantReadWriteLock</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%81%E9%99%8D%E7%BA%A7"><span class="toc-number">2.4.5.3.1.</span> <span class="toc-text">锁降级</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Condition%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.4.5.4.</span> <span class="toc-text">4. Condition介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Condition%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.5.4.1.</span> <span class="toc-text">Condition的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#J-U-C%E4%B9%8B%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">2.4.6.</span> <span class="toc-text">J.U.C之并发工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">2.4.6.1.</span> <span class="toc-text">CyclicBarrier</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CountDownLatch"><span class="toc-number">2.4.6.2.</span> <span class="toc-text">CountDownLatch</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90"><span class="toc-number">2.4.6.2.1.</span> <span class="toc-text">实现分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Semaphore"><span class="toc-number">2.4.6.3.</span> <span class="toc-text">Semaphore</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#J-U-C%E9%98%9F%E5%88%97"><span class="toc-number">2.4.7.</span> <span class="toc-text">J.U.C队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97ConcurrentLinkedQueue"><span class="toc-number">2.4.7.1.</span> <span class="toc-text">非阻塞队列ConcurrentLinkedQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97BlockingQueue"><span class="toc-number">2.4.7.2.</span> <span class="toc-text">阻塞队列BlockingQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-BlockingQueue%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.4.7.2.1.</span> <span class="toc-text">1. BlockingQueue接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-ArrayBlockingQueue"><span class="toc-number">2.4.7.2.2.</span> <span class="toc-text">2. ArrayBlockingQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-LinkedBlockingQueue"><span class="toc-number">2.4.7.2.3.</span> <span class="toc-text">3. LinkedBlockingQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-PriorityBlockingQueue"><span class="toc-number">2.4.7.2.4.</span> <span class="toc-text">3. PriorityBlockingQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-SynchronousQueue"><span class="toc-number">2.4.7.2.5.</span> <span class="toc-text">4. SynchronousQueue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#J-U-C%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.4.8.</span> <span class="toc-text">J.U.C线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadPoolExecutor%E5%88%86%E6%9E%90"><span class="toc-number">2.4.8.1.</span> <span class="toc-text">ThreadPoolExecutor分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81"><span class="toc-number">2.4.8.1.1.</span> <span class="toc-text">线程池状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.8.1.2.</span> <span class="toc-text">构造方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.4.8.2.</span> <span class="toc-text">四种线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-FixedThreadPool"><span class="toc-number">2.4.8.2.1.</span> <span class="toc-text">1. FixedThreadPool</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-SingleThreadExecutor"><span class="toc-number">2.4.8.2.2.</span> <span class="toc-text">2. SingleThreadExecutor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-CachedThreadPool"><span class="toc-number">2.4.8.2.3.</span> <span class="toc-text">3. CachedThreadPool</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-ScheduledThreadPool"><span class="toc-number">2.4.8.2.4.</span> <span class="toc-text">4. ScheduledThreadPool</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#J-U-C%E4%B9%8B%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8ConcurrentHashMap"><span class="toc-number">2.4.9.</span> <span class="toc-text">J.U.C之并发容器ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%AE%B9%E5%99%A8%E5%AF%B9%E5%BA%94%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="toc-number">2.4.9.1.</span> <span class="toc-text">集合框架容器对应的并发容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.4.9.2.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK7-HashMap"><span class="toc-number">2.4.9.3.</span> <span class="toc-text">JDK7 HashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK7-ConcurrentHashMap"><span class="toc-number">2.4.9.4.</span> <span class="toc-text">JDK7 ConcurrentHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK8-HashMap"><span class="toc-number">2.4.9.5.</span> <span class="toc-text">JDK8 HashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK8-ConcurrentHashMap"><span class="toc-number">2.4.9.6.</span> <span class="toc-text">JDK8 ConcurrentHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.4.9.7.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94Hashtable"><span class="toc-number">2.4.9.8.</span> <span class="toc-text">对比Hashtable</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/08/15/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="多线程，mysql面试题"><img src="https://api.ixiaowai.cn/gqapi/gqapi.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="多线程，mysql面试题"/></a><div class="content"><a class="title" href="/2021/08/15/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="多线程，mysql面试题">多线程，mysql面试题</a><time datetime="2021-08-15T11:26:17.960Z" title="发表于 2021-08-15 19:26:17">2021-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/15/%E4%BD%BF%E7%94%A8SFTP%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="使用SFTP的常用命令"><img src="https://api.mz-moe.cn/img.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用SFTP的常用命令"/></a><div class="content"><a class="title" href="/2021/08/15/%E4%BD%BF%E7%94%A8SFTP%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="使用SFTP的常用命令">使用SFTP的常用命令</a><time datetime="2021-08-15T11:01:04.604Z" title="发表于 2021-08-15 19:01:04">2021-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/15/Spring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/" title="Spring容器启动分析"><img src="https://api.mz-moe.cn/img.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring容器启动分析"/></a><div class="content"><a class="title" href="/2021/08/15/Spring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/" title="Spring容器启动分析">Spring容器启动分析</a><time datetime="2021-08-15T11:01:04.589Z" title="发表于 2021-08-15 19:01:04">2021-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/15/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" title="redis相关知识"><img src="https://api.ixiaowai.cn/gqapi/gqapi.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis相关知识"/></a><div class="content"><a class="title" href="/2021/08/15/redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" title="redis相关知识">redis相关知识</a><time datetime="2021-08-15T11:01:04.573Z" title="发表于 2021-08-15 19:01:04">2021-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/15/redis%E7%AC%94%E8%AE%B0/" title="redis笔记"><img src="https://api.ixiaowai.cn/gqapi/gqapi.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis笔记"/></a><div class="content"><a class="title" href="/2021/08/15/redis%E7%AC%94%E8%AE%B0/" title="redis笔记">redis笔记</a><time datetime="2021-08-15T11:01:04.573Z" title="发表于 2021-08-15 19:01:04">2021-08-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://api.mz-moe.cn/img.php')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By dingdang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="//at.alicdn.com/t/font_2621317_28l5j9w09dfi.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>